### 线程池的运作流程
因为在程序运行过程中，不断的创建和销毁线程，消耗内存，所以有了线程池的概念。即提前创建一些线程，也就是核心线程，每次需要线程的时候先判断核心线程是否已满，如果没满，就在线程池中取核心线程来创建任务线程就行。如果核心线程已满，那么判断任务队列是不是已经满了，如果任务队列没满，那就把任务放进任务队列即可。如果任务队列满了，就判断线程池的最大线程数是不是已经用完，如果没有用完就在非核心线程中申请，如果最大线程数都满了的情况下，就会拒绝执行任务。<br>
### 线程的状态
首先是创建一个线程，start()之后进入一个抢占cpu的状态，当抢占到cpu之后就开始执行线程，在线程执行过程中会遇到阻塞，这时候该对象没有执行的资格，会回到等待抢占cpu的状态，再进行执行，执行结束之后线程死亡。<br>
### static关键字
一、static关键字定义的变量只在本文件有效；二、static静态成员变量是申明，不是实现，所以不占内存；三、static静态成员函数只能使用静态成员变量，不能用非静态成员变量；四、static变量存放在数据区；<br>
### c++多态的理解
我对c++多态的理解就是：派生类的地址赋值给基类的指针，在基类中定义虚函数。然后在派生类如果有同名的函数，那么要看指针指向的是基类的对象还是派生类的对象了。以下是一个c++多态的一个例子：<br>
```c++
#include <iostream>
using namespace std;
class A
{
public:
    virtual void Print() { cout << "A::Print" << endl; }
};
class B : public A
{
public:
    virtual void Print() { cout << "B::Print" << endl; }
};
class D : public A
{
public:
    virtual void Print() { cout << "D::Print" << endl; }
};
class E : public B
{
    virtual void Print() { cout << "E::Print" << endl; }
};
int main()
{
    A  a; B b; D d; E e;
    A *pa = &a;  B *pb = &b;
    pa->Print();    //多态， a.Print()被调用，输出：A::Print
    pa = pb;        //基类指针pa指向派生类对象b
    pa->Print();  //b.Print()被调用，输出：B::Print
    pa = &d;       //基类指针pa指向派生类对象d
    pa->Print();  //多态， d. Print ()被调用,输出：D::Print
    pa = &e;       //基类指针pa指向派生类对象d
    pa->Print();  //多态， e.Print () 被调用,输出：E::Print
    return 0;
}
```
### 析构函数为什么要是虚函数
其实可以这么理解：这也是涉及到了多态的一个领域，如果基类指针指向他的派生类，那么如果这个指针在被删除的时候，由于是静态绑定，所以会自动调用基类的析构函数，如果基类的析构函数不是虚函数的话，那么派生类的析构函数不被调用，就不能得到析构。<br>
### 虚函数和纯虚函数的区别
首先，在形式上面，纯虚函数和虚函数前面都有一个virtual，但是纯虚函数在申明的时候后面会加一个"=0"。然后就是纯虚函数是在基类没有被定义，而纯虚函数是可以在基类被定义的。虚函数的存在是为了基类指针指向派生类的函数，从而实现多态。但是纯虚函数在子类中必须实现，如果不实现，那么这个派生类就会和基类一样，是个虚类。虚函数则不然，他可以在子类不做实现。
## Webserver
### I/O多路复用技术
I/O多路复用的本质是通过一种机制（系统内核缓冲IO数据），让单个进程去监视多个文件描述符，一旦某个描述符就绪，就能够通知程序进行相应的读写操作。
### 文件描述符
文件描述符是一个用于表述指向文件的引用的抽象化概念。文件描述符是个非负整数，实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或创建一个新文件时，内核向进程传一个文件描述符。在程序设计时，一些涉及底层的程序编写往往会围绕着文件描述符展开的。但是文件描述符多是用于Linux系统中。
### select、poll、epoll的区别
首先select是去轮询linux操作系统提供的fd_set这个类型的变量，poll函数轮询的是pollfd这个类型的数组，这个数组可以自己指定长度，而不是上面select函数只能轮询定长为FD_SETSIZE的fd_set变量。epoll不再是轮询，而是给每个文件描述符上发生的io事件设置一个回调函数。
### 定时器的实现
定时器用来处理超时的请求和长时间不活跃的连接，使用stl的priority_queue，基于小根堆的定时器关闭超时请求，并采用惰性删除的方式，时间的到来不会唤醒线程，而是每次循环的最后进行检查，如果超时了再删除，因为这里对超时的要求并不会很高，如果此时线程忙，那么检查时间会缩短，如果线程不忙的话，也给了超时请求更长的等待时间。此外还可以使用STL的set。

### 关于多线程
首先说明的是linux之前只支持的是多进程，当时是单核处理器，就算是多线程也是伪多线程，随着多核处理器的发展，c++11有了多线程的技术。主要应对的是高并发的场景，即多用户多请求的场景需要多线程的技术；线程后台处理大任务；大任务；

### https的流程
首先客户端发送请求给服务端，服务端收到请求后，生成一个公钥，以证书的形式发给客户端；客户端先验证公钥，如果验证失败的化，则请求失败，如果验证成功，客户端生成一个私钥，成为client key，用于对称加密数据。这时将client key 发送给服务端，服务端使用私钥进行解密，得到client key，使用client key对数据进行对称加密。将对称加密的数据传递给客户端，客户端使用非对称解密，得到服务器发送的数据，完成第二次HTTP请求。<br>
### put get post
这三个都是http协议的请求方式，get主要是向服务端请求资源，而put和post主要用于发送数据，put发送多个数据会进行覆盖，而post不会。
### 内存溢出、内存泄漏、内存越界
内存溢出：申请的内存的时候，没有足够的内存空间可以使用。<br>
内存泄漏：申请内存，并且使用后不归还，所以导致内存泄漏。<br>
内存越界：指的是超出申请的内存。
### 线程安全
首先要明白什么是线程安全，线程安全其实就是在存在共享变量的多个线程并行运行时，线程代码在同步机制下保证各个线程能够正确运行，不会出现资源污染的情况。
### c++线程同步的方式
主要有四个：一、互斥锁；二、条件变量；三、读写锁；四、信号量；
互斥锁：线程占用资源时，其他线程不得占用；<br>
条件变量：解决互斥锁的效率低的问题，如果一个线程因其他线程占用资源不得释放而等待，导致该线程阻塞。条件变量使得该线程睡眠，如果条件满足再唤醒该线程。<br>
读写锁：同一个资源可以让多个线程读，但是只能让一个线程写；所以读写锁也叫共享-占用锁。<br>
信号量：信号量可以让多个线程进入资源区。<br>
### 指针和引用的区别
指针存的是对象的地址，而引用是对象的别名，所以指针是可以为空的，而引用不能为空。<br>
从const角度来说，可以有const指针，但是没有const引用。<br>
指针的值初始化后可以改变，代表的是只想其他单元，但是引用初始化后就不能改变了。<br>
在做函数的形参时，指针传递其实本质还是值传递，将实参进行拷贝给形参。而引用其实传递的就是实参，因为是它的别名。<br>
常引用的使用场景：既想用引用提高程序的效率，又想保护传递给函数的参数不在函数中被改变，就要使用常引用。<br>
### 子类析构和父类析构的顺序
析构函数应该先调用子类的析构函数，然后再去析构父类的析构函数；构造函数应该先调用父类的构造函数，再去调用子类的构造函数。<br>
### 多态的实现
c++的多态主要体现在编译时和运行时两个方面，编译时的多态是通过函数和运算符重载来实现的，而运行时的多态是通过虚函数和继承来实现的：<br>
虚函数：在基类的函数用virtual来修饰，提供了一个接口，用做派生类对基类的虚函数重新定义。<br>
纯虚函数的作用：在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义，作为接口的纯虚函数不具备函数的作用，所以不能直接调用。<br>
从基类继承来的纯虚函数，在派生类中仍是虚函数，如果一个类至少有一个纯虚函数，这个类就是抽象类。
### 引用作为函数的返回值
好处就是不会在内存中产生返回值的副本，但是因此需要注意：一、千万不能把局部变量作为返回值，不言而喻，局部变量在函数运行结束后就会销毁，所以函数会报错；二、也不能返回函数内部new分配的内存的引用。<br>
###结构体和联合体的区别
一、在任意同一时刻，联合体中只存放一个被选中的成员，因为所有的成员共用一块地址空间，而结构体的所有成员都存在，因为不同成员存放的地址也不同啊。<br>
二、对于联合的不同成员赋值，将会对其他成员重写，而结构体则互相不影响。<br>
### overload和override的区别
重载是函数名相同，但是函数的形参不同；但是重写是子类对于父类的虚函数进行重新定义。<br>
其实重载是编译器对于重载函数的不同的参数表从而对函数名进行修饰，这样就会生成不同的函数。<br>
但是重写是跟多态真正相关的，当子类定义类父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用再编译期间是无法运行的，所以这样的函数地址是在运行期绑定的。
### 描述内存分配以及区别
1）静态存储区域分配。例如static变量和全局变量，在编译时就已经分配好内存。<br>
2）在栈上创建。在执行函数时，函数内部变量的存储单元可以在栈上创建，函数执行结束时这些存储单元自动被释放。<br>
3）从堆上分配，也称为动态内存分配。程序员在运行的时候用malloc或者new申请多少的内存，程序员自动决定。<br>
### 分别写出bool,int, float，指针类型的变量a与“零”的比较语句
bool if(!a) or if(a)<br>
int if(a == 0)<br>
float: const EXPRESSION EXP = 0.00001<br>
if(a < EXP && A > -EXP)<br>
指针 if(a != NULL) or if(a == NULL)<br>
### const相对于#define的优点
(1)、const 常量有数据类型，所以编译器会进行类型检查，而define只会进行字符检查。<br>
(2)、有些集成化的调试工具可以对const进行调试，但是不能对宏常量进行调试。
