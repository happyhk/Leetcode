### 线程池的运作流程
因为在程序运行过程中，不断的创建和销毁线程，消耗内存，所以有了线程池的概念。即提前创建一些线程，也就是核心线程，每次需要线程的时候先判断核心线程是否已满，如果没满，就在线程池中取核心线程来创建任务线程就行。如果核心线程已满，那么判断任务队列是不是已经满了，如果任务队列没满，那就把任务放进任务队列即可。如果任务队列满了，就判断线程池的最大线程数是不是已经用完，如果没有用完就在非核心线程中申请，如果最大线程数都满了的情况下，就会拒绝执行任务。<br>
### 线程的状态
首先是创建一个线程，start()之后进入一个抢占cpu的状态，当抢占到cpu之后就开始执行线程，在线程执行过程中会遇到阻塞，这时候该对象没有执行的资格，会回到等待抢占cpu的状态，再进行执行，执行结束之后线程死亡。<br>
### static关键字
一、static关键字定义的变量只在本文件有效；二、static静态成员变量是申明，不是实现，所以不占内存；三、static静态成员函数只能使用静态成员变量，不能用非静态成员变量；四、static变量存放在数据区；<br>
### c++多态的理解
我对c++多态的理解就是：派生类的地址赋值给基类的指针，在基类中定义虚函数。然后在派生类如果有同名的函数，那么要看指针指向的是基类的对象还是派生类的对象了。以下是一个c++多态的一个例子：<br>
```c++
#include <iostream>
using namespace std;
class A
{
public:
    virtual void Print() { cout << "A::Print" << endl; }
};
class B : public A
{
public:
    virtual void Print() { cout << "B::Print" << endl; }
};
class D : public A
{
public:
    virtual void Print() { cout << "D::Print" << endl; }
};
class E : public B
{
    virtual void Print() { cout << "E::Print" << endl; }
};
int main()
{
    A  a; B b; D d; E e;
    A *pa = &a;  B *pb = &b;
    pa->Print();    //多态， a.Print()被调用，输出：A::Print
    pa = pb;        //基类指针pa指向派生类对象b
    pa->Print();  //b.Print()被调用，输出：B::Print
    pa = &d;       //基类指针pa指向派生类对象d
    pa->Print();  //多态， d. Print ()被调用,输出：D::Print
    pa = &e;       //基类指针pa指向派生类对象d
    pa->Print();  //多态， e.Print () 被调用,输出：E::Print
    return 0;
}
```
### 析构函数为什么要是虚函数
其实可以这么理解：这也是涉及到了多态的一个领域，如果基类指针指向他的派生类，那么如果这个指针在被删除的时候，由于是静态绑定，所以会自动调用基类的析构函数，如果基类的析构函数不是虚函数的话，那么派生类的析构函数不被调用，就不能得到析构。<br>
### 虚函数和纯虚函数的区别
首先，在形式上面，纯虚函数和虚函数前面都有一个virtual，但是纯虚函数在申明的时候后面会加一个"=0"。然后就是纯虚函数是在基类没有被定义，而纯虚函数是可以在基类被定义的。虚函数的存在是为了基类指针指向派生类的函数，从而实现多态。但是纯虚函数在子类中必须实现，如果不实现，那么这个派生类就会和基类一样，是个虚类。虚函数则不然，他可以在子类不做实现。
## Webserver
### I/O多路复用技术
I/O多路复用的本质是通过一种机制（系统内核缓冲IO数据），让单个进程去监视多个文件描述符，一旦某个描述符就绪，就能够通知程序进行相应的读写操作。
### 文件描述符
文件描述符是一个用于表述指向文件的引用的抽象化概念。文件描述符是个非负整数，实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或创建一个新文件时，内核向进程传一个文件描述符。在程序设计时，一些涉及底层的程序编写往往会围绕着文件描述符展开的。但是文件描述符多是用于Linux系统中。
### select、poll、epoll的区别
首先select是去轮询linux操作系统提供的fd_set这个类型的变量，poll函数轮询的是pollfd这个类型的数组，这个数组可以自己指定长度，而不是上面select函数只能轮询定长为FD_SETSIZE的fd_set变量。epoll不再是轮询，而是给每个文件描述符上发生的io事件设置一个回调函数。
### 定时器的实现
定时器用来处理超时的请求和长时间不活跃的连接，使用stl的priority_queue，基于小根堆的定时器关闭超时请求，并采用惰性删除的方式，时间的到来不会唤醒线程，而是每次循环的最后进行检查，如果超时了再删除，因为这里对超时的要求并不会很高，如果此时线程忙，那么检查时间会缩短，如果线程不忙的话，也给了超时请求更长的等待时间。此外还可以使用STL的set。

### 关于多线程
首先说明的是linux之前只支持的是多进程，当时是单核处理器，就算是多线程也是伪多线程，随着多核处理器的发展，c++11有了多线程的技术。主要应对的是高并发的场景，即多用户多请求的场景需要多线程的技术；线程后台处理大任务；大任务；

### https的流程
首先客户端发送请求给服务端，服务端收到请求后，生成一个公钥，以证书的形式发给客户端；客户端先验证公钥，如果验证失败的化，则请求失败，如果验证成功，客户端生成一个私钥，成为client key，用于对称加密数据。这时将client key 发送给服务端，服务端使用私钥进行解密，得到client key，使用client key对数据进行对称加密。将对称加密的数据传递给客户端，客户端使用非对称解密，得到服务器发送的数据，完成第二次HTTP请求。<br>
### put get post
这三个都是http协议的请求方式，get主要是向服务端请求资源，而put和post主要用于发送数据，put发送多个数据会进行覆盖，而post不会。
### 内存溢出、内存泄漏、内存越界
内存溢出：申请的内存的时候，没有足够的内存空间可以使用。<br>
内存泄漏：申请内存，并且使用后不归还，所以导致内存泄漏。<br>
内存越界：指的是超出申请的内存。
### 线程安全
首先要明白什么是线程安全，线程安全其实就是在存在共享变量的多个线程并行运行时，线程代码在同步机制下保证各个线程能够正确运行，不会出现资源污染的情况。
### c++线程同步的方式
主要有四个：一、互斥锁；二、条件变量；三、读写锁；四、信号量；
互斥锁：线程占用资源时，其他线程不得占用；<br>
条件变量：解决互斥锁的效率低的问题，如果一个线程因其他线程占用资源不得释放而等待，导致该线程阻塞。条件变量使得该线程睡眠，如果条件满足再唤醒该线程。<br>
读写锁：同一个资源可以让多个线程读，但是只能让一个线程写；所以读写锁也叫共享-占用锁。<br>
信号量：信号量可以让多个线程进入资源区。<br>

