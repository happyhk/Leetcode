### 线程池的运作流程
因为在程序运行过程中，不断的创建和销毁线程，消耗内存，所以有了线程池的概念。即提前创建一些线程，也就是核心线程，每次需要线程的时候先判断核心线程是否已满，如果没满，就在线程池中取核心线程来创建任务线程就行。如果核心线程已满，那么判断任务队列是不是已经满了，如果任务队列没满，那就把任务放进任务队列即可。如果任务队列满了，就判断线程池的最大线程数是不是已经用完，如果没有用完就在非核心线程中申请，如果最大线程数都满了的情况下，就会拒绝执行任务。<br>
### 线程的状态
首先是创建一个线程，start()之后进入一个抢占cpu的状态，当抢占到cpu之后就开始执行线程，在线程执行过程中会遇到阻塞，这时候该对象没有执行的资格，会回到等待抢占cpu的状态，再进行执行，执行结束之后线程死亡。<br>
### static关键字
一、static关键字定义的变量只在本文件有效；二、static静态成员变量是申明，不是实现，所以不占内存；三、static静态成员函数只能使用静态成员变量，不能用非静态成员变量；四、static变量存放在数据区；<br>
### c++多态的理解
我对c++多态的理解就是：派生类的地址赋值给基类的指针，在基类中定义虚函数。然后在派生类如果有同名的函数，那么要看指针指向的是基类的对象还是派生类的对象了。以下是一个c++多态的一个例子：<br>
```c++
#include <iostream>
using namespace std;
class A
{
public:
    virtual void Print() { cout << "A::Print" << endl; }
};
class B : public A
{
public:
    virtual void Print() { cout << "B::Print" << endl; }
};
class D : public A
{
public:
    virtual void Print() { cout << "D::Print" << endl; }
};
class E : public B
{
    virtual void Print() { cout << "E::Print" << endl; }
};
int main()
{
    A  a; B b; D d; E e;
    A *pa = &a;  B *pb = &b;
    pa->Print();    //多态， a.Print()被调用，输出：A::Print
    pa = pb;        //基类指针pa指向派生类对象b
    pa->Print();  //b.Print()被调用，输出：B::Print
    pa = &d;       //基类指针pa指向派生类对象d
    pa->Print();  //多态， d. Print ()被调用,输出：D::Print
    pa = &e;       //基类指针pa指向派生类对象d
    pa->Print();  //多态， e.Print () 被调用,输出：E::Print
    return 0;
}
```
### 析构函数为什么要是虚函数
其实可以这么理解：这也是涉及到了多态的一个领域，如果基类指针指向他的派生类，那么如果这个指针在被删除的时候，由于是静态绑定，所以会自动调用基类的析构函数，如果基类的析构函数不是虚函数的话，那么派生类的析构函数不被调用，就不能得到析构。<br>




