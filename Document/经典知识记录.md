### 线程池的运作流程
因为在程序运行过程中，不断的创建和销毁线程，消耗内存，所以有了线程池的概念。即提前创建一些线程，也就是核心线程，每次需要线程的时候先判断核心线程是否已满，如果没满，就在线程池中取核心线程来创建任务线程就行。如果核心线程已满，那么判断任务队列是不是已经满了，如果任务队列没满，那就把任务放进任务队列即可。如果任务队列满了，就判断线程池的最大线程数是不是已经用完，如果没有用完就在非核心线程中申请，如果最大线程数都满了的情况下，就会拒绝执行任务。<br>
### 线程的状态
首先是创建一个线程，start()之后进入一个抢占cpu的状态，当抢占到cpu之后就开始执行线程，在线程执行过程中会遇到阻塞，这时候该对象没有执行的资格，会回到等待抢占cpu的状态，再进行执行，执行结束之后线程死亡。<br>
### static关键字
一、static关键字定义的变量只在本文件有效；二、static静态成员变量是申明，不是实现，所以不占内存；三、static静态成员函数只能使用静态成员变量，不能用非静态成员变量；四、static变量存放在数据区；<br>
### c++多态的理解
我对c++多态的理解就是：派生类的地址赋值给基类的指针，在基类中定义虚函数。然后在派生类如果有同名的函数，那么要看指针指向的是基类的对象还是派生类的对象了。以下是一个c++多态的一个例子：<br>
```c++
#include <iostream>
using namespace std;
class A
{
public:
    virtual void Print() { cout << "A::Print" << endl; }
};
class B : public A
{
public:
    virtual void Print() { cout << "B::Print" << endl; }
};
class D : public A
{
public:
    virtual void Print() { cout << "D::Print" << endl; }
};
class E : public B
{
    virtual void Print() { cout << "E::Print" << endl; }
};
int main()
{
    A  a; B b; D d; E e;
    A *pa = &a;  B *pb = &b;
    pa->Print();    //多态， a.Print()被调用，输出：A::Print
    pa = pb;        //基类指针pa指向派生类对象b
    pa->Print();  //b.Print()被调用，输出：B::Print
    pa = &d;       //基类指针pa指向派生类对象d
    pa->Print();  //多态， d. Print ()被调用,输出：D::Print
    pa = &e;       //基类指针pa指向派生类对象d
    pa->Print();  //多态， e.Print () 被调用,输出：E::Print
    return 0;
}
```
### 析构函数为什么要是虚函数
其实可以这么理解：这也是涉及到了多态的一个领域，如果基类指针指向他的派生类，那么如果这个指针在被删除的时候，由于是静态绑定，所以会自动调用基类的析构函数，如果基类的析构函数不是虚函数的话，那么派生类的析构函数不被调用，就不能得到析构。<br>
### 虚函数和纯虚函数的区别
首先，在形式上面，纯虚函数和虚函数前面都有一个virtual，但是纯虚函数在申明的时候后面会加一个"=0"。然后就是纯虚函数是在基类没有被定义，而纯虚函数是可以在基类被定义的。虚函数的存在是为了基类指针指向派生类的函数，从而实现多态。但是纯虚函数在子类中必须实现，如果不实现，那么这个派生类就会和基类一样，是个虚类。虚函数则不然，他可以在子类不做实现。
## Webserver
### I/O多路复用技术
I/O多路复用的本质是通过一种机制（系统内核缓冲IO数据），让单个进程去监视多个文件描述符，一旦某个描述符就绪，就能够通知程序进行相应的读写操作。
### 文件描述符
文件描述符是一个用于表述指向文件的引用的抽象化概念。文件描述符是个非负整数，实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或创建一个新文件时，内核向进程传一个文件描述符。在程序设计时，一些涉及底层的程序编写往往会围绕着文件描述符展开的。但是文件描述符多是用于Linux系统中。
### select、poll、epoll的区别
首先select是去轮询linux操作系统提供的fd_set这个类型的变量，poll函数轮询的是pollfd这个类型的数组，这个数组可以自己指定长度，而不是上面select函数只能轮询定长为FD_SETSIZE的fd_set变量。epoll不再是轮询，而是给每个文件描述符上发生的io事件设置一个回调函数。
### 定时器的实现
定时器用来处理超时的请求和长时间不活跃的连接，使用stl的priority_queue，基于小根堆的定时器关闭超时请求，并采用惰性删除的方式，时间的到来不会唤醒线程，而是每次循环的最后进行检查，如果超时了再删除，因为这里对超时的要求并不会很高，如果此时线程忙，那么检查时间会缩短，如果线程不忙的话，也给了超时请求更长的等待时间。此外还可以使用STL的set。

### 关于多线程
首先说明的是linux之前只支持的是多进程，当时是单核处理器，就算是多线程也是伪多线程，随着多核处理器的发展，c++11有了多线程的技术。主要应对的是高并发的场景，即多用户多请求的场景需要多线程的技术；线程后台处理大任务；大任务；

### https的流程
首先客户端发送请求给服务端，服务端收到请求后，生成一个公钥，以证书的形式发给客户端；客户端先验证公钥，如果验证失败的化，则请求失败，如果验证成功，客户端生成一个私钥，成为client key，用于对称加密数据。这时将client key 发送给服务端，服务端使用私钥进行解密，得到client key，使用client key对数据进行对称加密。将对称加密的数据传递给客户端，客户端使用非对称解密，得到服务器发送的数据，完成第二次HTTP请求。<br>
### put get post
这三个都是http协议的请求方式，get主要是向服务端请求资源，而put和post主要用于发送数据，put发送多个数据会进行覆盖，而post不会。
### 内存溢出、内存泄漏、内存越界
内存溢出：申请的内存的时候，没有足够的内存空间可以使用。<br>
内存泄漏：申请内存，并且使用后不归还，所以导致内存泄漏。<br>
内存越界：指的是超出申请的内存。
### 线程安全
首先要明白什么是线程安全，线程安全其实就是在存在共享变量的多个线程并行运行时，线程代码在同步机制下保证各个线程能够正确运行，不会出现资源污染的情况。
### c++线程同步的方式
主要有四个：一、互斥锁；二、条件变量；三、读写锁；四、信号量；
互斥锁：线程占用资源时，其他线程不得占用；<br>
条件变量：解决互斥锁的效率低的问题，如果一个线程因其他线程占用资源不得释放而等待，导致该线程阻塞。条件变量使得该线程睡眠，如果条件满足再唤醒该线程。<br>
读写锁：同一个资源可以让多个线程读，但是只能让一个线程写；所以读写锁也叫共享-占用锁。<br>
信号量：信号量可以让多个线程进入资源区。<br>
### 指针和引用的区别
指针存的是对象的地址，而引用是对象的别名，所以指针是可以为空的，而引用不能为空。<br>
从const角度来说，可以有const指针，但是没有const引用。<br>
指针的值初始化后可以改变，代表的是只想其他单元，但是引用初始化后就不能改变了。<br>
在做函数的形参时，指针传递其实本质还是值传递，将实参进行拷贝给形参。而引用其实传递的就是实参，因为是它的别名。<br>
常引用的使用场景：既想用引用提高程序的效率，又想保护传递给函数的参数不在函数中被改变，就要使用常引用。<br>
### 子类析构和父类析构的顺序
析构函数应该先调用子类的析构函数，然后再去析构父类的析构函数；构造函数应该先调用父类的构造函数，再去调用子类的构造函数。<br>
### 多态的实现
c++的多态主要体现在编译时和运行时两个方面，编译时的多态是通过函数和运算符重载来实现的，而运行时的多态是通过虚函数和继承来实现的：<br>
虚函数：在基类的函数用virtual来修饰，提供了一个接口，用做派生类对基类的虚函数重新定义。<br>
纯虚函数的作用：在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义，作为接口的纯虚函数不具备函数的作用，所以不能直接调用。<br>
从基类继承来的纯虚函数，在派生类中仍是虚函数，如果一个类至少有一个纯虚函数，这个类就是抽象类。
### 引用作为函数的返回值
好处就是不会在内存中产生返回值的副本，但是因此需要注意：一、千万不能把局部变量作为返回值，不言而喻，局部变量在函数运行结束后就会销毁，所以函数会报错；二、也不能返回函数内部new分配的内存的引用。<br>
###结构体和联合体的区别
一、在任意同一时刻，联合体中只存放一个被选中的成员，因为所有的成员共用一块地址空间，而结构体的所有成员都存在，因为不同成员存放的地址也不同啊。<br>
二、对于联合的不同成员赋值，将会对其他成员重写，而结构体则互相不影响。<br>
### overload和override的区别
重载是函数名相同，但是函数的形参不同；但是重写是子类对于父类的虚函数进行重新定义。<br>
其实重载是编译器对于重载函数的不同的参数表从而对函数名进行修饰，这样就会生成不同的函数。<br>
但是重写是跟多态真正相关的，当子类定义类父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用再编译期间是无法运行的，所以这样的函数地址是在运行期绑定的。
### 描述内存分配以及区别
1）静态存储区域分配。例如static变量和全局变量，在编译时就已经分配好内存。<br>
2）在栈上创建。在执行函数时，函数内部变量的存储单元可以在栈上创建，函数执行结束时这些存储单元自动被释放。<br>
3）从堆上分配，也称为动态内存分配。程序员在运行的时候用malloc或者new申请多少的内存，程序员自动决定。<br>
### 分别写出bool,int, float，指针类型的变量a与“零”的比较语句
bool if(!a) or if(a)<br>
int if(a == 0)<br>
float: const EXPRESSION EXP = 0.00001<br>
if(a < EXP && A > -EXP)<br>
指针 if(a != NULL) or if(a == NULL)<br>
### const相对于#define的优点
(1)、const 常量有数据类型，所以编译器会进行类型检查，而define只会进行字符检查。<br>### int(*s[10])(int)表示的是
int(*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。<br>
(2)、有些集成化的调试工具可以对const进行调试，但是不能对宏常量进行调试。
### c++文件的过程
首先的预处理的过程，将宏定义、内联函数之类的转换为代码体。接着是编译阶段，进行代码检查，接着是汇编过程，就是将cpp文件进行编译成二进制文件，最后是链接，将不同的二进制文件链接成可执行文件或者库文件。<br>
[!image](https://img-blog.csdnimg.cn/20181107094829293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NjbF9EaWxpZ2VudA==,size_16,color_FFFFFF,t_70)
### c++11的新特性
1、引入了nullptr，之前的c++是用的NULL，用nullptr是用来区分NULL和0；<br>
2、引入了auto,可以根据上下语句来判断与确定变量的格式；<br>
3、引入了智能指针，shared_ptr\unique_ptr\weak_ptr<br>
4、引入了委托构造和继承构造。<br>


### （此题之前亲自遇见过）数组和指针的区别
(1) 修改内容上的差别<br>
数组修改是按照下表修改，而指针的修改是修改整个字符串的首地址。<br>
(2) 用sizeof可以计算数组的容量，而sizeof(p)，则得到的是一个指针的字节数，而不是指针指向的内存容量。<br>

### malloc的底层原理
malloc内存分配主要用到了brk系统调用函数和mmap系统调用函数，如果申请的内存小于128k，则用brk系统调用，它的工作原理主要是将指向虚拟内存的指针向高地址处移动来申请内存的。如果申请的内存大于128k。那么用mmap函数来实现，mmap其实是在空闲内存中去申请一块内存，这样的好处就是delete时，brk不能完全释放，而mmap是完全释放的。<br>
具体的博客如下：[链接](https://www.cnblogs.com/zpcoding/p/10808969.html)

### STL的allocator
allocator类是c++的一个模板，它提供类型化的内存分配以及对象的分配和销毁。<br>
allocator称为分配器。<br>
STL的分配器用于封装STL容器在内存管理上的底层细节。在C++中，其内存配置和释放如下：<br>
new运算分为两个阶段：（1）调用::operator new 配置内存；（2）调用对象构造函数构造对象内容<br>
delete运算分为两个阶段：（1）调用对象析构函数；（2）调用::opeartor delete释放内存
为了精密分工，STL allocator将两个阶段操作区分开来：<br>
内存配置有alloc::allocate()负责，<br>
内存释放由alloc::deallocate()负责；<br>
对象构造由::construct()负责，<br>
对象析构由::destroy()负责。<br>

### hash表的底层实现原理
hash表的实现主要是依靠哈希函数来实现的，根据键值对应的函数值。但是这样会遇到冲突，怎么解决。一、开放地址法；二、链地址法；三、再哈希法。<br>

### TCP/IP模型
首先TCP/IP模型是针对OSI七层模型提出的，主要分为应用层（应用层、表示层、会话层）、网络层、传输层、网络接口层（数据链路层、物理层）。<br>
接下来需要注意的是TCP的连接和断开，连接：首先要认识几个标志位和序号：<br>
SYN:表示建立连接<br>
ACk:表示确认序号有效<br>
FIN:表示关闭连接<br>
RST:表示连接重置<br>
PSH:表示有DATA数据传输<br>
三次握手的过程：（图解）<br>
![image](https://upload-images.jianshu.io/upload_images/11948845-f7df13ddc74b4508.png?imageMogr2/auto-orient/strip|imageView2/2/w/1118/format/webp)

### close_wait 和 time_wait的区别
close_wait 指的是被关闭的一端在接受客户端的关闭请求后，本身没有关闭，而是等待上层程序的关闭请求的过程，time_wait指的是主动关闭一端的过程，主要是在本端已经关闭的前提下，收到对端的关闭请求并且将ACK发送出去后所处的状态，这种状态表示：双方都已经完成工作，只是为了确保迟来的数据报能被是被并丢弃，可靠的终止TCP连接。<br>

### 常见的设计模式 
单例模式：主要解决的是一个全局使用的类的频繁的创建和销毁的问题。单例模式下可以确保其一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。单例模式有三个要素：一、某个类只有一个实例；二、它必须自行创建这个实例；三、它必须向整个系统提供这个实例。<br>
工厂模式：工厂模式的具体介绍在[链接](https://github.com/happyhk/WorkLearning/blob/master/DesignPattern/README.md)<br>
观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都会得到通知并且做出更新。
### C++中的explict
为了防止隐式转换
### C++智能指针与底层实现
1、智能指针<br>
智能指针是一个类，这个类的构造函数传入一个普通指针，析构函数中释放传入的指针。智能指针是栈上的对象，所以当函数结束时就会自动释放。<br>
2、最常用的智能指针<br>
unique_ptr::不支持复制和赋值，如果一定要赋值：std::unique_ptr<int> p1 = std::move(p2);<br>
shared_ptr: 支持赋值，是基于引用计数的智能指针，直到内存的引用计数为0的时候这个内存会被释放。<br>
weak_ptr: 弱引用，引用计数有个问题就是互相引用形成环，这两个指针指向的内存都无法释放，需要手动打破这个循环引用。也就是weak_ptr只引用但不计数。如果shared_ptr和weak_ptr同时引用，当所有的shared_ptr析构之后，不管weak_ptr是否引用该内存，内存都会被释放。所以weak_ptr不能保证它指向的内存一定有效，在使用之前要检查weak_ptr是否为空指针。<br>

### c++ 右值引用
先说一下区别：左值引用在于等号左边，右值引用在等号右边，并且，左值引用引用的是一个明确变量的地址，而右值引用引用的是一个常量。<br>
并且右值引用可以修改常量的量。<br>

## 进程
### 进程的状态切换
进程有三个状态：一、就绪；二、运行；三、阻塞。只有运行和就绪可以相互转换。就绪状态当获取CPU的时间片从而可以转为运行状态，当进程缺少需要的资源的时候会进入一个阻塞的状态。<br>
### 进程调度算法
一、批处理系统：（1）、先来先服务；（2）、最短时间剩余；（3）、短作业优先；<br>
二、交互式系统：（1）、时间片轮转；（2）、优先级调度；（3）、多级反馈队列；<br>
三、实时系统；<br>
### 进程同步
1、临界区：对临界资源进行访问的那段代码叫做临界区。<br>
2、同步与互斥：多的进程因为合作产生制约关系，使得进程有一定的先后执行关系。而互斥指的是同一时刻只有一个进程能进入临界区。<br>
3、信号量:信号量是一个整型变量，可以对它进行up和down的操作。如果信号量大于0，执行-1操作，如果信号量等于0，进程睡眠，等待信号量大于0；up：是对信号量执行+1操作，唤醒睡眠的进程让其完成down操作。<br>
4、管程
### 进程通信
1、管道
2、匿名管道
3、信号量
4、消息队列
5、共享内存
6、套接字
